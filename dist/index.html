<!DOCTYPE html>
<html>
	<head>
    <meta http-equiv="content-type" content="text/html; charset=UTF-8" />
    <title>Gravity Game</title>
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/3.2.1/jquery.min.js"></script>
	</head>
	<body>
		<center>
			<canvas id="gameCanvas" width="1200" height="700" style="border:1px solid #000000;"></canvas>
		</center>
		<span id="message"></span>
		<script>
		const GRID_LINE_INTERVAL = 1000;

		class Rect {
			constructor(x, y, width, height) {
				this.x = x;
				this.y = y;
				this.width = width;
				this.height = height;
			}
		}

		class Vector {
			constructor(x, y) {
				this.x = x;
				this.y = y;
			}

			withMagnitude(m) {
				var ret = new Vector(this.x, this.y);
				var scale = m / this.magnitude();
				ret.x *= scale;
				ret.y *= scale;
				return ret;
			}

			magnitude() {
				return Math.sqrt(this.x * this.x + this.y * this.y);
			}
		}

		class Universe {
			constructor() {
				this.state = null;
			}

			getBody(id) {
				return id in this.state["Bodies"] ? this.state["Bodies"][id] : null;
			}

			draw(context, focus) {
				var min = new Vector(0, 0);
				var max = new Vector(context.canvas.width, context.canvas.height);

				if (focus) {
					var r = focus["Radius"];
					min.x = focus["Position"]["X"] - r * 30;
					max.x = focus["Position"]["X"] + r * 30;
					min.y = focus["Position"]["Y"] - r * 30;
					max.y = focus["Position"]["Y"] + r * 30;
				} else {
					var padding = 100;
					for (const [id, body] of Object.entries(this.state["Bodies"])) {
						if (body["Static"]) {
							continue;
						}
						var pos = new Vector(body["Position"]["X"], body["Position"]["Y"]);
						var r = body["Radius"];
						if (pos.x - r - padding < min.x) {
							min.x = pos.x - r - padding;
						}
						if (pos.y - r - padding < min.y) {
							min.y = pos.y - r - padding;
						}
						if (pos.x + r + padding > max.x) {
							max.x = pos.x + r + padding;
						}
						if (pos.y + r + padding > max.y) {
							max.y = pos.y + r + padding;
						}
					}
				}

				context.clearRect(0, 0, context.canvas.width, context.canvas.height);
				var scaleX = context.canvas.width / (max.x - min.x);
				var scaleY = context.canvas.height / (max.y - min.y);
				var scale = scaleX > scaleY ? scaleY : scaleX;
				context.scale(scale, scale);
				context.translate(-min.x, -min.y);

				var bounds = new Rect(this.state["Bounds"]["X"], this.state["Bounds"]["Y"], this.state["Bounds"]["W"], this.state["Bounds"]["H"])

				for (var x = bounds.x; x < bounds.x + bounds.width; x += GRID_LINE_INTERVAL) {
					context.beginPath();
					context.strokeStyle = '#000000';
					context.lineWidth = 10;
					context.moveTo(x, bounds.y);
					context.lineTo(x, bounds.y + bounds.height);
					context.stroke();
				}
				for (var y = bounds.y; y < bounds.y + bounds.height; y += GRID_LINE_INTERVAL) {
					context.beginPath();
					context.strokeStyle = '#000000';
					context.lineWidth = 10;
					context.moveTo(bounds.x, y);
					context.lineTo(bounds.x + bounds.width, y);
					context.stroke();
				}

				this.drawBodies(context);
				this.drawBounds(context);

				context.translate(min.x, min.y);
				context.scale(1.0 / scale, 1.0 / scale);
			}

			drawBodies(context) {
				for (const [id, body] of Object.entries(this.state["Bodies"])) {
					var r = body["Radius"];
					var f = new Vector(body["NetForce"]["X"], body["NetForce"]["Y"]);
					var pos = new Vector(body["Position"]["X"], body["Position"]["Y"])
					var mass = body["Mass"]

					var fMag = f.magnitude();
					var fNorm = new Vector(f.x / fMag, f.y / fMag);

					context.beginPath();
					context.arc(pos.x, pos.y, r, 0, 2 * Math.PI);
					context.fillStyle = this.color;
					context.fill();
					context.lineWidth = 5;
					context.strokeStyle = '#003300';
					context.stroke();

					context.lineWidth = 2;
					context.strokeStyle = '#FF00FF';
					context.globalAlpha = 0.7;
					context.setLineDash([20, 15]);
					context.beginPath();
					var lStart = new Vector(pos.x + r * fNorm.x, pos.y + r * fNorm.y);
					context.moveTo(lStart.x, lStart.y);
					context.lineTo(lStart.x + f.x / mass, lStart.y + f.y / mass);
					context.stroke();
					context.setLineDash([]);
					context.globalAlpha = 1.0;
				}
			}

			drawBounds(context) {
				context.rect(this.state["Bounds"]["X"], this.state["Bounds"]["Y"], this.state["Bounds"]["W"], this.state["Bounds"]["H"]);
				context.stroke();
			}
		}

		class PlayerState {
			constructor() {
				this.topThrustEnabled = false;
				this.bottomThrustEnabled = false;
				this.leftThrustEnabled = false;
				this.rightThrustEnabled = false;
			}

			render() {
				var state = {
					Thrust: {
						x: 0.0,
						y: 0.0,
					},
				};
				if (this.topThrustEnabled) {
					state.Thrust.y += 1.0;
				}
				if (this.bottomThrustEnabled) {
					state.Thrust.y -= 1.0;
				}
				if (this.leftThrustEnabled) {
					state.Thrust.x -= 1.0;
				}
				if (this.rightThrustEnabled) {
					state.Thrust.x += 1.0;
				}
				return state
			}
		}

		var canvas = document.getElementById('gameCanvas');
		var context = canvas.getContext("2d");
		var universe = new Universe()
		var playerState = new PlayerState()

		var playerBodyId = null;

		function update(state) {
			universe.state = state;
  			var playerBody = universe.getBody(playerBodyId);
			universe.draw(context, playerBody || null);
		}

		var ws = new WebSocket('ws://127.0.0.1:8080/game');
		ws.onmessage = function(e) {
			document.getElementById('message').innerText = e.data;
			const data = JSON.parse(e.data);
			if (data["GameState"]) {
				update(data["GameState"]["Universe"]);
				ws.send(JSON.stringify(playerState.render()));
			}
			if (data["AssignedBodyId"]) {
				playerBodyId = data["AssignedBodyId"];
			}
		};
		ws.onerror = function(e) {
			document.getElementById('message').innerText = 'unable to connect';
		};

    $(document).keydown(function(e) {
			if (playerBodyId == null) {
				return;
			}
			switch (e.which) {
				case 37: // left
					playerState.leftThrustEnabled = true;
					break;
				case 38: // up
					playerState.topThrustEnabled = true;
					break;
				case 39: // right
					playerState.rightThrustEnabled = true;
					break;
				case 40: // down
					playerState.bottomThrustEnabled = true;
					break;
				default:
					return;
			}
			e.preventDefault();
    });

    $(document).keyup(function(e) {
			if (playerBodyId == null) {
				return;
			}
			switch (e.which) {
				case 37: // left
					playerState.leftThrustEnabled = false;
					break;
				case 38: // up
					playerState.topThrustEnabled = false;
					break;
				case 39: // right
					playerState.rightThrustEnabled = false;
					break;
				case 40: // down
					playerState.bottomThrustEnabled = false;
					break;
				default:
					return;
			}
			e.preventDefault();
    });
		</script>
	</body>
</html>
